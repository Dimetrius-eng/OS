# Work-case 1

**Виконав: студент групи РПЗ-33, Руденко Дмитро**

<div align="justify"> 

#### 1. Опишіть для чого використовують git, які основні дії та команди в ньому виконують.

<blockquote>
  
**1.1. Для чого використовують Git?**
  
**Git** — це розподілена система керування версіями (VCS). Вона представляє собою своєрідну "машину часу" для коду. 
- Git може **відстежувати зміни**, запам'ятовуючи кожен рядок коду, який було змінено. Якщо після оновлення скрипта наш продукт перестав працювати, ми можемо за секунду повернутися до версії, яка була годину тому.
- Також тут забезпечено **спільну роботу**, коли декілька програмістів можуть працювати над одним файлом одночасно. Git допоможе об'єднати їхні правки.
- **Гілкування (Branching)** виявляється у можливості створення окремої гілки для тестування нової механіки гри. Якщо ідея виявиться невдалою — можна просто видалити гілку, не пошкодивши основний робочий код.
- Завдяки сервісам типу GitHub або GitLab, код зберігається в хмарі. Якщо з ноутбуком щось станеться, проєкт не зникне (забезпечено **резервне копіювання**).

**1.2. Основні стадії стану файлів у Git**

- **Working Directory:** робоча папка, де ми просто пишемо код.
- **Staging Area (Index):** "чернетка" або "зона очікування". Сюди ми додаємо зміни, які хочемо включити у наступний "знімок".
- **Repository (.git folder):** місце, де Git назавжди зберігає історію наших коммітів.

**1.3. Основні дії та команди**

| Категорія | Команда | Опис дії |
| :--- | :--- | :--- |
| **Початок роботи** | **git init** | Створює новий порожній репозиторій у поточній папці |
| | **git clone [url]** | Копіює існуючий проєкт із сервера (наприклад, з GitHub) на комп'ютер |
| **Щоденний цикл (Add, Commit, Push)** | **git status** | Показує, які файли було змінено і що ще не додано до звіту |
| | **git add [file]** | Додає файл у Staging Area. Команда git add . додає одразу всі змінені файли |
| | **git commit -m "Опис змін"** | Створює "знімок" проєкту. Важливо писати зрозумілі коментарі (наприклад, "Fixed player jump logic") |
| | **git push** | Відправляє локальні комміти на сервер (наприклад, у репозиторій на GitHub) |
| **Робота з гілками (Branching)** | **git branch** | Показує список усіх гілок |
| | **git checkout -b [name]** | Створює нову гілку і перемикається на неї |
| | **git merge [name]** | Об'єднує вказану гілку з тією, у якій ми зараз перебуваємо |
| **Отримання змін** | **git pull** | Завантажує останні зміни з сервера та автоматично об'єднує їх із кодом. Корисно, якщо працюємо у команді або з двох різних ПК |

**1.4. Чому це важливо для моїх проєктів?**

Коли я розробляв свій VBA-інструмент в Excel або веб-гру Alias, я стикався з тим, що помилка в одному рядку ламала все. З Git я просто можу написати git checkout ., і всі помилкові зміни скасуються.
Також у папці проєкту завжди варто створювати файл .gitignore. Наприклад, для Unity він відфільтровує тимчасові файли папок Library та Temp, щоб репозиторій не важив гігабайти непотрібного сміття.

</blockquote>

#### 2. Що таке "комміт", як він дозволяє відслідковувати зміни у файлах?

<blockquote>
  
**Комміт (commit)** — це одна з найважливіших операцій у Git. Якщо пояснювати просто, це «знімок» (snapshot) стану проєкту в конкретний момент часу.
Коли ми робимо комміт, Git не просто копіює змінені файли. Він створює запис у своїй базі даних, який містить:

- **Знімок дерева файлів:** посилання на стан усіх файлів проєкту на цей момент.
- **Метадані:** хто зробив зміни (автор), коли це сталося (дата/час) та унікальний ідентифікатор (Хеш-сума SHA-1).
- **Коментар:** наш опис того, що саме було зроблено.
- **Посилання на батьківський коміт:** кожен новий коміт знає, який був до нього, що створює безперервний ланцюжок історії.

Git відстежує зміни через порівняння станів, порівнюючи поточний знімок із попереднім. Він бачить, які файли були додані, змінені або видалені. Також Git використовує спеціальні алгоритми (хешування). Якщо було змінено хоча б одну кому в коді, хеш-сума файлу зміниться, і Git миттєво це зафіксує. Завдяки тому, що кожен коміт посилається на попередній, можна переглянути всю історію змін за допомогою команди git log. Це дозволяє побачити різницю між будь-якими двома моментами розробки.

</blockquote>

#### 3. Зареєструйте власний git-аккаунт (gitlab, github або інша платформа). Створіть новий публічний репозиторій, який будете використовувати для додавання всіх виконаних робіт з дисципліни «Операційні системи» (якщо працюєте в команді долучіть інших учасників команди до його редакторів).

Для виконання робіт з дисципліни «Операційні системи» я використовую свій раніше створений профіль на платформі GitHub. У межах цього профілю було створено публічний репозиторій під назвою "OS", призначений для зберігання та систематизації всіх звітів, кодів та проєктів, виконаних під час навчання. 

**Посилання на репозиторій:** [Репозиторій для ОС](https://github.com/Dimetrius-eng/OS/tree/main).

Репозиторій налаштований для відстеження змін у файлах лабораторних робіт. Нижче наведено скріншот головної сторінки репозиторію, що підтверджує його назву, структуру та наявність файлів README.md.

![Скріншот головної сторінки репозиторію](Скріншот головної сторінки репозиторію.jpg)


#### 4. Розмістіть свій перший колективний звіт про виконаний Work-case 1 (рекомендовано робити як md-сторінку) у даному репозиторії. У git мають бути комміти від кожного учасника команди
